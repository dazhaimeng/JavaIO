<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Chapter 1.5  Buffers and Channels</title>
  </head>
  
  <body>
    <h2>Chapter 1.5 缓存和通道(Buffers and Channels)</h2>
	<pre>
		只要一个程序在同一时间读或写的东西程序只有一个,流的速度是相当快的.实际上,
	瓶颈更多是在硬盘读写和网络速度上,而不是Java程序自身.但是当一个程序要同时读写多个流
	的时候,情况就有些不一样了.这种情况在web服务器上经常发生,例如,一个处理器应用可能会
	与上百个甚至数千个客户端同时通信.
	
		在任何时候,流都可能阻塞(block).就是说,它会暂时停止接受更多的请求来等待实际
	硬件的读或写赶上它的速度.这可能发生在磁盘上,更是网络连接的重大问题.很明显,你不想因
	为一个人的网络拥堵就停止对999个客户端发送数据.在Java1.4之前传统的解决方法是给每个
	连接分配一个不同的线程.500个客户端就需要500个线程.每个线程可以独立运行,所以其他线
	程的连接缓慢不会导致每个线程都减慢速度.
	
		但是,多线程不是无开销的.创建和管理线程需要做很多工作,而且很少有虚拟机能同时
	处理超过1000个线程或创建如此多的线程而不造成严重的性能下降.创建数千个线程会使最健
	壮的虚拟机都崩溃掉.不过,大型服务器需要有同时与数千个客户沟通的能力.
	
		在Java1.4中发明的解决方案是非阻塞I/O(nonblocking I/O).在非阻塞I/O中,流被转移
	到一个支持的角色,主要的工作都是由缓存和通道来完成.
		
	</pre>
  </body>
</html>
